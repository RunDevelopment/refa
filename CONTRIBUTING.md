# Contributing


## Writing code

A few general rules:

- Write unit tests.
- Strongly type everything (except what is trivially inferred).
- Document as much as possible but nothing obvious. (No `i++; // increase variable`)
- Use an IDE that supports ESLint. This will take care of formatting and give warnings and errors.
- Use existing naming conventions (camelCase for functions and variables, PascalCase for classes, interfaces, and types.).

Useful commands:

- `npm run test:fast`
    Run all test except the slow ones.
- `npm run build`
    Compiles the whole project and creates the final `index.{ts,d.ts}` files in the project's root directory.
- `npm run scripts:debug`
    This will execute the `scripts/debug.ts` file. This is a quick way to test new or existing features with access to all files in the library.


## Project structure

```
refa/
|-- scripts/
|   `-- ...
|-- src/
|   |-- iter/
|   |   `-- ...
|   |-- js/
|   |   `-- ...
|   `-- ...
|-- tests/
|   |-- helper/
|   |   `-- ...
|   `-- ...
|-- CONTRIBUTING.md  // this file
|-- index.{ts,d.ts}  // generated by `npm run build`
|-- package.json
`-- ...
```

### `scripts`

This folder contains useful scripts when working on refa. Any script can be executed via `npm run scripts:<script-name>`.

The `debug` script is particularly useful. It's purpose is to be way to quickly try out things. It as access to all of refa's source files and can be run via `npm run scripts:debug`. Do not commit changes to this file.

### `src`

This is folder for all files which will be in the compiled build of the library.

The most important files are:

1. `ast.ts` includes the definition of refa's RE AST format and simple functions for traversal, modification, and output.
1. `char{set,map}.ts` defines the most important classes of refa: `CharSet` - a sorted interval set used to represent characters - and `CharMap` - a sorted interval map.
1. `finite-automaton.ts` defines interfaces all concrete FA implementations use.
1. `{dfa,nfa}.ts` define the concrete implementations of an NFA and DFA.
1. `words.ts` includes function to convert from JS strings to number arrays and vise versa among others.

#### `src/iter`

This directory contains functions that consume and produce graph iterators. Graph iterators are one of refa's core concepts and allow us to implement different algorithms independently from one specific graph representation.

When importing those functions from outside `src/iter`, it must be done via `src/iter/index.ts`. It's recommended to import all functions like this:

```js
import * as Iter from "./iter";
```

From inside `src/iter`, functions MUST be imported directly from the file they are defined in.

#### `src/js`

This is where all [JavaScript RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp)-specific logic lives. This is mainly includes a parser to convert RegExp to refa's RE AST format and a function to convert RE AST to JS RegExp.

Files from `src/*` (except `index.ts`) are not allowed to import files from `src/js`. The rest of the library is supposed to be independent from this part of it because it may later be moved to its own package.

### `test`

This folder has a similar layout to `src`. It's supposed to somewhat mirror the file structure of `src`, so it's easy to find where tests for specific files form `src` live.

You can run all tests using `npm run test` (or just `npm test`).

If you want to run the tests quicker, you can use `npm run test:fast`. This will run all tests except the stress test which is executed for thousands of regexes.

The `helper` folder contains functions used to implement tests. This includes useful constant, conversions function, and sets of test regexes.


## refa's RE AST format

refa uses its own AST format to represent regular expressions. The RE AST format is language agnostic and comparatively simple.

It supports:

- Concatenation (e.g. `ab`)
- Alternation (e.g. `a|b`)
- Quantifiers (e.g. `a{4,6}`, `a{2,}`, `a?`, `a*`)
- Lookarounds (e.g. `(?=a)`, `(?<!a)`)
- Characters are represented by an interval set of symbols

Some features like lazy quantifiers, atomic groups, and capturing groups might be added in the future.

Features like backreferences and recursion will never be support because their implementation details are very specific to the underlying regex engine and cannot be represented in an language-agnostic way.

### Converting to and from the RE AST format

JavaScript regular expressions can be converted to the RE AST format by using `JS.Parser`. `JS.toLiteral` converts into the other direction.
Note that the conversion from JS RegExp to the RE AST format is lossy and sometime impossible due to the limitations of the RE AST format.

Converters for the regex dialects of other programming languages might be added in the future as separate packages.
