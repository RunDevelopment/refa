import * as fs from "fs";
import * as path from "path";
import { CharSet } from "../src/char-set";
import { runEncodeCharacters } from "../src/char-util";
import { printRanges } from "./util";


const CaseFoldingCommon: ReadonlyMap<number, number> = require("unicode-13.0.0/Case_Folding/C/code-points");
const CaseFoldingSimple: ReadonlyMap<number, number> = require("unicode-13.0.0/Case_Folding/S/code-points");


createCaseFoldingFile(UTF16CanonicalizeIgnoreCase, 0xFFFF, "UTF16", "utf16-case-folding.ts");
createCaseFoldingFile(UnicodeCanonicalizeIgnoreCase, 0x10FFFF, "Unicode", "unicode/case-folding.ts");

function UTF16CanonicalizeIgnoreCase(ch: number): number {
	// https://tc39.es/ecma262/#sec-runtime-semantics-canonicalize-ch

	const s = String.fromCharCode(ch);
	const u = s.toUpperCase();
	if (u.length !== 1) {
		return ch;
	}
	const cu = u.charCodeAt(0);
	if (ch >= 128 && cu < 128) {
		return ch;
	}
	return cu;
}

function UnicodeCanonicalizeIgnoreCase(ch: number): number {
	// https://tc39.es/ecma262/#sec-runtime-semantics-canonicalize-ch

	let mapping = CaseFoldingCommon.get(ch);
	if (mapping !== undefined) {
		return mapping;
	}
	mapping = CaseFoldingSimple.get(ch);
	if (mapping !== undefined) {
		return mapping;
	}

	return ch;
}

function createCaseFoldingFile(
	canonicalize: (ch: number) => number,
	maxCharacter: number,
	variablePrefix: string,
	filename: string
): void {

	const canonicalizeMapping = new Map<number, number[]>();
	for (let ch = 0; ch <= maxCharacter; ch++) {
		const c = canonicalize(ch);
		let list = canonicalizeMapping.get(c);
		if (list === undefined) {
			canonicalizeMapping.set(c, list = []);
		}
		list.push(ch);
	}

	const caseFolding: number[][] = [];
	canonicalizeMapping.forEach(chars => {
		chars.forEach(c => {
			caseFolding[c] = chars;
		});
	});

	let count = 0;
	const CASE_VARYING = CharSet.empty(maxCharacter).union(runEncodeCharacters(function* () {
		for (let i = 0; i < maxCharacter; i++) {
			const fold = caseFolding[i];
			if (fold.indexOf(i) === -1) {
				throw new Error(`The case folding of ${i} does not include itself.`);
			}
			if (fold.length > 1) {
				count++;
				yield i;
			}
		}
	}()));

	const map: Record<number, number[]> = {};
	caseFolding.forEach((fold, i) => {
		if (fold.length > 1) {
			map[i] = fold;
		}
	});

	console.log(`${variablePrefix}: ${count} characters vary in case`);


	const code = `/* eslint-disable */

// DO NOT EDIT!
// THIS FILE IS GENERATED BY scripts/create-case-folding.js

import { CharSet } from "${"../".repeat(filename.split(/\//g).length)}char-set";


/**
 * A character set of all characters that have at least one case variation.
 */
export const ${variablePrefix}CaseVarying: CharSet = CharSet.empty(${maxCharacter}).union(${
	printRanges(CASE_VARYING.ranges)
});

/**
 * A map for a given character to all it case variations. The list of case variations also includes the key character
 * itself.
 *
 * If the given character do not have case variations, it will not be part of this map.
 */
export const ${variablePrefix}CaseFolding: Readonly<Record<number, readonly number[]>> = JSON.parse(${
	JSON.stringify(JSON.stringify(map))
});
`;

	fs.writeFileSync(path.join(__dirname, "../src/js", filename), code, "utf-8");
}
