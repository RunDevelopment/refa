import { promises as fs } from "fs";

// This is a parser for .d.ts files generated by Dts bundle.
// It will inline all generated modules into the main module.


const JS_STRING = /"(?:[^"\\\r\n]|\\[\s\S])*"|'(?:[^'\\\r\n]|\\[\s\S])*'/y;
const JS_IDENT = /[a-zA-Z_]\w*/y;
const JS_M_COMMENT = /\/\*(?:[^*]|\*(?!\/))*\*\//y;
const JS_COMMENT = /\/\*(?:[^*]|\*(?!\/))*\*\/|\/\/.*(?!.)/y;

async function run() {
	const parsed = parseDts(await fs.readFile("./index.d.ts", "utf8"));
	parsed.banner = "";

	ensureUniqueNames(parsed);
	ensureInternalExportAll(parsed);
	ensureSoleExport(parsed);

	let output = outputModContext(inline(parsed).modules.refa);

	// Dirty hack to fix an error
	output = output.replace("TransitionIterator<MapFABuilderNode>", "TransitionIterator<FAIterators.MapFABuilderNode>");

	await fs.writeFile("./index.d.ts", output, "utf8");
}
run().catch(err => {
	console.log(err);
	process.exit(1);
});

function ensureUniqueNames(parsed: ParsedDts): void {
	const names = new Map<string, { modName: string }>();

	for (const modName in parsed.modules) {
		const mod = parsed.modules[modName];
		for (const mem of mod.members) {
			let collision = names.get(mem.name);
			if (collision && collision.modName !== modName) {
				throw new Error(`The name ${JSON.stringify(mem.name)} is present in both ${JSON.stringify(modName)} and ${JSON.stringify(collision.modName)}.`)
			}
			names.set(mem.name, { modName });
		}
		for (const imp of mod.imports) {
			if (!isExternal(parsed, imp.from)) {
				continue;
			}
			if (imp.type === "ns") {
				for (const name of imp.names) {
					let collision = names.get(name);
					if (collision) {
						throw new Error(`The name ${JSON.stringify(name)} is present in both ${JSON.stringify(modName)} and ${JSON.stringify(collision.modName)}.`)
					}
					names.set(name, { modName });
				}
			}
		}
	}
}
function ensureInternalExportAll(parsed: ParsedDts): void {
	for (const modName in parsed.modules) {
		const mod = parsed.modules[modName];
		for (const exp of mod.exports) {
			if (exp.type === "ns" && !isExternal(parsed, exp.from)) {
				throw new Error(`Potentially partial export of "${exp.from}" in "${modName}" not allowed.`)
			}
		}
	}
}
function ensureSoleExport(parsed: ParsedDts): void {
	const exportedBy = new Map<string, string>();

	for (const modName in parsed.modules) {
		const mod = parsed.modules[modName];
		for (const { from } of mod.exports) {
			if (from === parsed.main) {
				throw new Error(`The main module "${parsed.main}" cannot be exported by another module.`);
			}

			const alsoExports = exportedBy.get(from);
			if (alsoExports) {
				throw new Error(`The both "${modName}" and "${alsoExports}" export "${from}". At most one module is allowed to export another module.`);
			}

			exportedBy.set(from, modName);
		}
	}
}
function isExternal(parsed: ParsedDts, from: string): boolean {
	return from !== parsed.main && !from.startsWith(parsed.main + "/");
}

function inline(parsed: Readonly<ParsedDts>): ParsedDts {
	const inlined: ParsedDts = {
		banner: parsed.banner,
		main: parsed.main,
		modules: {
			[parsed.main]: inlineMod(parsed.modules[parsed.main])
		},
	};

	function inlineMod(mod: Readonly<ParsedModule>): ParsedModule {
		const inlined: ParsedModule = {
			comment: mod.comment,
			imports: mod.imports.filter(i => isExternal(parsed, i.from)),
			exports: [],
			members: [],
		};

		for (const exp of mod.exports) {
			if (isExternal(parsed, exp.from)) {
				inlined.exports.push(exp);
				continue;
			}

			switch (exp.type) {
				case "all": {
					const nested = inlineMod(parsed.modules[exp.from]);
					inlined.imports.push(...nested.imports);
					inlined.exports.push(...nested.exports);
					inlined.members.push(...nested.members);
					break;
				}
				case "all-as": {
					const nested = inlineMod(parsed.modules[exp.from]);
					inlined.imports.push(...nested.imports);
					inlined.exports.push(...nested.exports);
					inlined.members.push({
						type: "namespace",
						exported: true,
						name: exp.as,
						source: null as any,
						members: nested.members,
						comment: exp.comment || nested.comment
					});
					break;
				}
				case "ns": {
					throw new Error("Disallowed ns export.");
				}
				default:
					assertNever(exp);
			}
		}

		inlined.members.push(...mod.members);
		return inlined;
	}

	return inlined;
}

interface OutputOptions {
	moduleNameMap?: Record<string, string>;
}
function output(parsed: ParsedDts, options?: OutputOptions): string {
	function mapModName(name: string): string {
		return options?.moduleNameMap?.[name] ?? name;
	}

	let s = parsed.banner + "\n\n";
	for (const modName in parsed.modules) {
		const mod = parsed.modules[modName];
		s += `declare module ${JSON.stringify(mapModName(modName))} {\n`;
		s += outputModContext(mod, options);
		s += "}\n\n";
	}

	return s.replace(/\r\n/g, "\n");
}
function outputModContext(mod: ParsedModule, options?: OutputOptions): string {
	function mapModName(name: string): string {
		return options?.moduleNameMap?.[name] ?? name;
	}

	let s = "";
	if (mod.comment) {
		s += mod.comment + "\n";
	}

	for (const imp of mod.imports) {
		switch (imp.type) {
			case "ns":
				s += `import {${imp.names.join(", ")}} from ${JSON.stringify(mapModName(imp.from))};\n`;
				break;
			default:
				assertNever(imp.type);
		}
	}

	for (const exp of mod.exports) {
		switch (exp.type) {
			case "ns":
				s += `export {${exp.names.join(", ")}} from ${JSON.stringify(mapModName(exp.from))};\n`;
				break;
			case "all":
				s += `export * from ${JSON.stringify(mapModName(exp.from))};\n`;
				break;
			case "all-as":
				if (exp.comment) {
					s += exp.comment + "\n";
				}
				s += `export * as ${exp.as} from ${JSON.stringify(mapModName(exp.from))};\n`;
				break;
			default:
				assertNever(exp);
		}
	}

	for (const mem of mod.members) {
		s += outputMember(mem, false, options);
		s += "\n";
	}
	return s;
}
function outputMember(mem: Member, insideNamespace: boolean, options?: OutputOptions): string {
	let s = "";

	if (mem.comment) {
		s += mem.comment + "\n";
	}
	if (mem.exported && !insideNamespace) {
		s += "export ";
	}

	if (mem.type === "simple") {
		s += mem.source.text;
	} else {
		s += "namespace " + mem.name + " {\n";
		for (const m of mem.members) {
			s += outputMember(m, true, options);
			s += "\n";
		}
		s += "}";
	}

	return s;
}


interface ParsedDts {
	banner: string;
	main: string;
	modules: Record<string, ParsedModule>;
}
interface ParsedModule {
	comment?: string;
	imports: Import[];
	exports: Export[];
	members: Member[];
}

type Import = NsImport;
interface ImportBase {
	type: Import["type"];
	from: string;
}
interface NsImport extends ImportBase {
	type: "ns",
	names: string[];
}

type Export = AllExport | AllAsExport | NsExport;
interface ExportBase {
	type: Export["type"];
	from: string;
}
interface AllExport extends ExportBase {
	type: "all",
}
interface AllAsExport extends ExportBase {
	type: "all-as",
	as: string;
	comment?: string;
}
interface NsExport extends ExportBase {
	type: "ns",
	names: string[];
}

type Member = SimpleMember | NamespaceMember;
interface MemberBase {
	type: Member["type"];
	name: string;
	source: SourceCode;
	comment?: string;
	exported?: boolean;
}
interface SimpleMember extends MemberBase {
	type: "simple"
}
interface NamespaceMember extends MemberBase {
	type: "namespace"
	members: Member[];
}

function parseDts(code: string): ParsedDts {
	const source = SourceCode.fromText(code);
	source.consumeSpaces();

	const banner = source.consume(/\/\/.*$(?:\s*\/\/.*$)*/my, "Expected comment")[0];
	source.consumeSpaces();

	const modules: Record<string, ParsedModule> = {};
	let main: string | undefined = undefined;
	while (source.good) {
		const [name, module] = parseModule(source);
		source.consumeSpaces();

		modules[name] = module;
		if (main === undefined) {
			main = name;
		}
	}

	if (main === undefined) {
		throw new Error("Expected at least one module");
	}

	return { banner, main, modules };
}
function parseModule(source: SourceCode): [string, ParsedModule] {
	const modPattern = reBuild(/\bdeclare\s+module\s+(<<JS_STRING>>)/y, { JS_STRING });

	const name = stringValue(source.consume(modPattern, "Expected module")[1]);
	source.consumeSpaces();

	const block = consumeBracket(source, "{", "}");
	return [name, parseModuleContent(block.slice(1, block.length - 1))];
}
function parseModuleContent(modSource: SourceCode): ParsedModule {
	modSource.consumeSpaces();

	const module: ParsedModule = {
		imports: [],
		exports: [],
		members: [],
	};

	let moduleComment = modSource.peek(JS_M_COMMENT)?.[0];
	if (moduleComment && /^\s*(?:\*\s*)?@module\b/m.test(moduleComment)) {
		module.comment = moduleComment;

		modSource.consumeOptional(JS_M_COMMENT);
		modSource.consumeSpaces();
	}

	while (modSource.good) {
		const docComment = modSource.consumeOptional(JS_M_COMMENT);
		modSource.consumeSpaces();

		modSource.consumeAnyOf([
			{
				pattern: reBuild(/export\s*\*\s*(?:as\s+(<<JS_IDENT>>)\s*)?from\s*(<<JS_STRING>>);?/y, { JS_STRING, JS_IDENT }),
				action(match, slice, invalid) {
					const from = stringValue(match[2]);
					const as = match[1];

					if (as) {
						module.exports.push({
							type: "all-as",
							as,
							from,
							comment: docComment ? docComment[0] : undefined
						});
					} else {
						if (docComment) {
							invalid("Unexpected comment before export.");
						}

						module.exports.push({
							type: "all",
							from
						});
					}
				}
			},
			{
				pattern: reBuild(/export\s*(\{[^{}]*\})\s*from\s*(<<JS_STRING>>);?/y, { JS_STRING }),
				action(match, slice, invalid) {
					if (docComment) {
						invalid("Unexpected comment before export.");
					}
					const from = stringValue(match[2]);

					const nsIndex = match[0].indexOf("{");
					const nsSlice = slice.slice(nsIndex, nsIndex + match[1].length);

					module.exports.push({
						type: "ns",
						names: parseNameList(nsSlice),
						from
					});
				}
			},
			{
				pattern: reBuild(/import\s*(?:type\s*)?(\{[^{}]*\})\s*from\s*(<<JS_STRING>>);?/y, { JS_STRING }),
				action(match, slice, invalid) {
					if (docComment) {
						invalid("Unexpected comment before import.");
					}
					const from = stringValue(match[2]);

					const nsIndex = match[0].indexOf("{");
					const nsSlice = slice.slice(nsIndex, nsIndex + match[1].length);

					module.imports.push({
						type: "ns",
						names: parseNameList(nsSlice),
						from
					});
				}
			},
			{
				pattern: /(export\s+)?(?=(?:function|interface|class|type|var|let|const|namespace)\s)/y,
				action([, exportDecl]) {
					const member = parseMember(modSource);
					if (exportDecl) {
						member.exported = true;
					}
					if (docComment) {
						member.comment = docComment[0];
					}
					module.members.push(member);
				}
			},
			{
				pattern: /export\s*\{\s*\}\s*;/y,
				action() {
					// I have no idea what these things do, so let's just ignore them for now
				}
			},
		], "Unsupported module element");

		modSource.consumeSpaces();
	}

	return module;
}

function parseNameList(source: SourceCode): string[] {
	const names: string[] = [];

	source.consume(/\{/y, "Expected '{'");
	source.consumeSpaces();

	if (!source.consumeOptional(/,/y)) {
		const ident = reBuild(/<<JS_IDENT>>/y, { JS_IDENT });
		let name;
		while (name = source.consumeOptional(ident)) {
			names.push(name[0]);

			source.consumeSpaces();
			source.consume(/(?!as\b)/y, "Aliases are not supported");
			if (!source.consumeOptional(/,/y)) {
				break;
			} else {
				source.consumeSpaces();
			}
		}
	} else {
		source.consumeSpaces();
	}

	source.consume(/\}/y, "Expected '}'");

	return names;
}

function parseMember(memSource: SourceCode): Member {
	const [, type, name] = memSource.consume(reBuild(/(?=(function|interface|class|type|var|let|const|namespace)\s+(<<JS_IDENT>>))/y, { JS_IDENT }), "Invalid member");

	let source;
	switch (type) {
		case "function":
			source = consumeFunction(memSource);
			break;
		case "interface":
			source = consumeInterface(memSource);
			break;
		case "class":
			source = consumeClass(memSource);
			break;
		case "type":
			source = consumeType(memSource);
			break;
		case "var":
		case "let":
		case "const":
			source = consumeVariable(memSource);
			break;
		case "namespace":
			return parseNamespace(memSource);
		default:
			memSource.error(memSource.pos, "Unsupported type.");
	}

	return {
		type: "simple",
		name,
		source,
	};
}
function parseNamespace(source: SourceCode): NamespaceMember {
	let start = source.pos;

	source.consume(/namespace(?=\s)/y, "Expected 'namespace' keyword");
	source.consumeSpaces();
	const name = source.consume(JS_IDENT, "Expected namespace name")[0];
	source.consumeSpaces();
	source.consume(/\{/y, "Expected '{'");
	source.consumeSpaces();

	const members: Member[] = [];
	while (source.peekChar() !== "}") {
		const docComment = source.consumeOptional(JS_M_COMMENT);
		source.consumeSpaces();
		const member = parseMember(source);
		source.consumeSpaces();

		if (docComment) {
			member.comment = docComment[0];
		}
		members.push(member);
	}

	source.consume(/\}/y, "Expected '}'");

	return {
		type: "namespace",
		name,
		source: source.slice(start, source.pos),
		members,
	}
}

function consumeFunction(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(/function(?=\s)/y, "Expected 'function' keyword");
	source.consumeSpaces();
	source.consume(JS_IDENT, "Expected function name");
	source.consumeSpaces();
	if (source.peekChar() === "<") {
		consumeBracket(source, "<", ">");
		source.consumeSpaces();
	}
	consumeBracket(source, "(", ")");
	source.consumeSpaces();
	if (source.peekChar() === ":") {
		consumeTypeAnnotation(source);
		source.consumeSpaces();
	}
	source.consume(/;/y, "Excepted ';' to end function declaration.");
	return source.slice(start, source.pos);
}
function consumeVariable(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(/(?:var|let|const)(?=\s)/y, "Expected 'var', 'let', or 'const' keyword");
	source.consumeSpaces();
	source.consume(JS_IDENT, "Expected variable name");
	consumeTSUntil(source, ";");
	return source.slice(start, source.pos);
}
function consumeClass(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(/class(?=\s)/y, "Expected 'class' keyword");
	source.consumeSpaces();
	source.consume(JS_IDENT, "Expected class name");
	source.consumeSpaces();
	if (source.consumeOptional(/(?=<)/y)) {
		consumeBracket(source, "<", ">");
		source.consumeSpaces();
	}
	if (source.consumeOptional(/extends(?=\s)/y)) {
		source.consumeSpaces();
		consumeRefList(source);
		source.consumeSpaces();
	}
	if (source.consumeOptional(/implements(?=\s)/y)) {
		source.consumeSpaces();
		consumeRefList(source);
		source.consumeSpaces();
	}
	consumeBracket(source, "{", "}");
	return source.slice(start, source.pos);
}
function consumeInterface(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(/interface(?=\s)/y, "Expected 'interface' keyword");
	source.consumeSpaces();
	source.consume(JS_IDENT, "Expected interface name");
	source.consumeSpaces();
	if (source.consumeOptional(/(?=<)/y)) {
		consumeBracket(source, "<", ">");
		source.consumeSpaces();
	}
	if (source.consumeOptional(/extends(?=\s)/y)) {
		source.consumeSpaces();
		consumeRefList(source);
		source.consumeSpaces();
	}
	consumeBracket(source, "{", "}");
	return source.slice(start, source.pos);
}
function consumeType(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(/type(?=\s)/y, "Expected 'type' keyword");
	source.consumeSpaces();
	source.consume(JS_IDENT, "Expected type name");
	consumeTSUntil(source, ";");
	return source.slice(start, source.pos);
}
function consumeTypeAnnotation(source: SourceCode): SourceCode {

	let start = source.pos;
	source.consume(/:/y, "Expected ':'");
	source.consumeSpaces();

	if (source.consumeOptional(/(?:asserts\s+)?\w+\s+is\b/y)) {
		source.consumeSpaces();
	}

	while (true) {
		// readonly
		while (source.consumeOptional(/readonly\b/y)) {
			source.consumeSpaces();
		}

		// we assume that the type annotation is valid TS
		source.consumeAnyOf([
			{
				pattern: /(?=([([{<]))/y,
				action([, open]) {
					consumeBracket(source, open, CLOSING_BRACKET[open]);
				}
			},
			{
				pattern: reBuild(/(?=<<JS_IDENT>>)/y, { JS_IDENT }),
				action() {
					consumeRef(source);
				}
			},
		], "Unsupported type annotation element.");

		// array
		while (source.consumeOptional(/\s*\[\s*\]/y)) { }

		if (source.consumeOptional(/\s*(?:[&|]|=>)/y)) {
			source.consumeSpaces();
		} else {
			break;
		}
	}
	return source.slice(start, source.pos);
}
function consumeTSUntil(source: SourceCode, stop: string): SourceCode {
	let counter = 0;

	const stopEscape = charToHexEscape(stop.charCodeAt(0));
	const disallowed = RegExp(`[^${stopEscape}{}()\\[\\]<>"'/]`)

	return source.consumeAnyUntil([
		{
			pattern: RegExp(stopEscape, "y"),
			action() {
				return counter === 0;
			}
		},
		{
			pattern: /[(\[{<]/y,
			action() {
				counter++;
			}
		},
		{
			pattern: /[)\]}>]/y,
			action() {
				counter--;
			}
		},
		{
			pattern: reBuild(/(<<disallowed>>|<<JS_STRING>>|<<JS_COMMENT>>)+/my, { JS_STRING, JS_COMMENT, disallowed }),
			action() { }
		},
	], "Unended expression");
}
function consumeRef(source: SourceCode): SourceCode {
	let start = source.pos;
	source.consume(JS_IDENT, "Expected identifier");
	while (source.consumeOptional(/\s*\.\s*/y)) {
		source.consume(JS_IDENT, "Expected identifier");
	}
	if (source.consumeOptional(/\s*(?=<)/y)) {
		consumeBracket(source, "<", ">");
	}
	return source.slice(start, source.pos);
}
function consumeRefList(source: SourceCode): SourceCode {

	let start = source.pos;
	consumeRef(source);
	while (source.consumeOptional(/\s*\,\s*/y)) {
		consumeRef(source);
	}
	return source.slice(start, source.pos);
}

function stringValue(strLiteral: string): string {
	return eval(strLiteral);
}

const CLOSING_BRACKET: Record<string, string> = {
	"(": ")",
	"[": "]",
	"{": "}",
	"<": ">",
}
function consumeBracket(source: SourceCode, open: string, close: string): SourceCode {
	if (source.peekChar() !== open) {
		source.error(source.pos, `The bracket doesn't start with the expected character ${JSON.stringify(open)}.`);
	}

	const openEscape = charToHexEscape(open.charCodeAt(0));
	const closeEscape = charToHexEscape(close.charCodeAt(0));
	const disallowed = RegExp(`[^${openEscape}${closeEscape}"'/]`)

	let counter = 0;

	return source.consumeAnyUntil([
		{
			pattern: RegExp(openEscape, "y"),
			action() {
				counter++;
			}
		},
		{
			pattern: RegExp(closeEscape, "y"),
			action() {
				counter--;
				return counter === 0;
			}
		},
		{
			pattern: reBuild(/(<<disallowed>>|<<JS_STRING>>|<<JS_COMMENT>>)+/my, { JS_STRING, JS_COMMENT, disallowed }),
			action() { }
		},
	], "Missing closing " + close);
}


interface PatternAction<T> {
	pattern: RegExp;
	action(match: RegExpExecArray, slice: SourceCode, invalid: (message: string) => never): T;
}

function findLastIndex<T>(array: readonly T[], pred: (item: T) => boolean): number {
	for (let i = array.length - 1; i >= 0; i--) {
		if (pred(array[i])) {
			return i;
		}
	}
	return -1;
}
class SourcePositionTranslator {
	private readonly _lineOffsets: number[];
	private readonly _length: number;
	constructor(text: string) {
		const lineRE = /\r\n?|\n/g;
		let m;

		this._lineOffsets = [0];
		this._length = text.length;

		while ((m = lineRE.exec(text))) {
			this._lineOffsets.push(m.index + m[0].length);
		}
	}

	at(pos: number): { line: number; column: number } | undefined {
		if (pos < 0 || pos > this._length) {
			return undefined;
		} else {
			let lineIndex = findLastIndex(this._lineOffsets, offset => pos >= offset);
			let column = pos - this._lineOffsets[lineIndex];
			return { line: lineIndex + 1, column };
		}
	}
}
class SourceCode {
	readonly text: string;
	readonly sliceIndex: number;
	readonly posTranslator: SourcePositionTranslator;
	pos: number = 0;

	private constructor(text: string, sliceIndex: number, posTranslator: SourcePositionTranslator) {
		this.text = text;
		this.sliceIndex = sliceIndex;
		this.posTranslator = posTranslator;
	}
	static fromText(text: string): SourceCode {
		return new SourceCode(text, 0, new SourcePositionTranslator(text));
	}

	get length(): number {
		return this.text.length;
	}
	get good(): boolean {
		return this.pos < this.text.length;
	}

	/**
	 * Returns the character at the current position.
	 */
	peekChar(): string {
		return this.text[this.pos];
	}
	peek(pattern: RegExp): RegExpExecArray | null {
		if (!pattern.sticky) {
			throw new Error("The pattern has to be sticky.");
		}
		pattern.lastIndex = this.pos;
		const m = pattern.exec(this.text);
		return m;
	}

	slice(start: number, end: number): SourceCode {
		return new SourceCode(this.text.substring(start, end), start + this.sliceIndex, this.posTranslator);
	}
	consumeAsSlice(length: number): SourceCode {
		const slice = this.slice(this.pos, this.pos + length);
		this.pos += length;
		return slice;
	}

	skip(length: number) {
		this.pos += length;
	}

	consumeOptional(pattern: RegExp): RegExpExecArray | null {
		if (!pattern.sticky) {
			throw new Error("The pattern has to be sticky.");
		}
		pattern.lastIndex = this.pos;
		const m = pattern.exec(this.text);
		if (m) {
			this.pos += m[0].length;
		}
		return m;
	}
	consume(pattern: RegExp, errorMessage: string): RegExpExecArray {
		const m = this.consumeOptional(pattern);
		if (!m) {
			this.error(this.pos, errorMessage);
		}
		return m;
	}
	consumeAnyOf<T>(patterns: Iterable<PatternAction<T>>, errorMessage: string): T {
		for (const { pattern, action } of patterns) {
			const orgPos = this.pos;
			const m = this.consumeOptional(pattern);
			if (m) {
				const slice = this.slice(orgPos, orgPos + m[0].length);
				return action(m, slice, msg => {
					throw new Error(`Invalid format: ${msg}\nAt ${this._at(orgPos + this.sliceIndex)}\n\n${m[0]}`);
				});
			}
		}
		throw new Error(`Invalid format: ${errorMessage}\nAt ${this._at(this.pos + this.sliceIndex)}\n\n${this.text.substr(this.pos, 80)}`);
	}
	consumeAnyUntil(patterns: readonly PatternAction<boolean | void>[], errorMessage: string): SourceCode {
		const initialPos = this.pos;
		while (this.good) {
			const orgPos = this.pos;
			for (const { pattern, action } of patterns) {
				const m = this.consumeOptional(pattern);
				if (m) {
					const slice = this.slice(orgPos, orgPos + m[0].length);
					const done = action(m, slice, msg => {
						this.error(orgPos, msg);
					});
					if (done) {
						return this.slice(initialPos, this.pos);
					} else {
						break;
					}
				}
			}
			if (this.pos === initialPos) {
				this.error(this.pos, errorMessage);
			}
		}
		this.error(this.pos, errorMessage);
	}

	consumeSpaces(): void {
		this.consume(/\s*/y, "Expected spaces");
	}

	error(pos: number, message: string): never {
		throw new Error(`Invalid format: ${message}\nAt ${this._at(pos + this.sliceIndex)}\n\n${this.text.substr(pos, 80)}`);
	}

	private _at(pos: number): string {
		const result = this.posTranslator.at(pos);
		if (result) {
			return `${result.line}:${result.column}`;
		} else {
			return "pos: " + pos;
		}
	}
}


function reBuild(base: RegExp, subs: Record<string, RegExp>): RegExp {
	const source = base.source.replace(/<<(\w+)>>/g, (_, name) => {
		const sub = subs[name];
		if (!sub) {
			throw new Error(`Unknown name <<${name}>>`);
		}
		[...sub.flags].filter(f => f !== "g" && f !== "y").forEach(f => {
			if (base.flags.indexOf(f) === -1) {
				throw new Error(`The ${f} flag is required by <<${name}>> but not present in the base pattern.`);
			}
		});
		return `(?:${sub.source})`;
	});
	return RegExp(source, base.flags);
}

function charToHexEscape(char: number): string {
	if (char === 0) {
		return "\\0";
	} else if (char < 256) {
		return "\\x" + char.toString(16).padStart(2, "0");
	} else {
		return "\\u" + char.toString(16).padStart(4, "0");
	}
}

function assertNever(value: never): never {
	throw new Error("");
}
